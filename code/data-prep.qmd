---
title: "Data Preparation"
format: pdf
editor: visual
author: Sophia Yang
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: load-packages
#| include: false

library(readxl)
library(tidyverse)
library(binom)
library(kableExtra)
library(patchwork)
```

## Load Data

```{r}
#| label: load-data
#| eval: false

file1 <- read_excel("J:/Individual Working Folders/Research Assistants/Yang, Sophia/exported data for project, terms 1080 to 1570 V2.xlsx", 
                    guess_max = 1000000)

file2 <- read_excel("J:/Individual Working Folders/Research Assistants/Yang, Sophia/exported data for project, terms 1580 and forward V2.xlsx", 
                    guess_max = 10000)

combined_df <- rbind(file1, file2)
```

```{r}
#| echo: false
library(here)
combined_df <- readRDS(here("data", "1-combined.rds"))
```

```{r}
#| label: missing-data-before

missing_summary <- combined_df |>
  summarise(across(
    everything(),
    list(
      n_missing = ~sum(is.na(.)),
      prop_missing = ~mean(is.na(.))
    ),
    .names = "{.col}-{.fn}"
  )) |>
  pivot_longer(
    everything(),
    names_to = c("variable", ".value"),
    names_sep = "-"
  ) |>
  arrange(desc(n_missing))
          
print(missing_summary, n = Inf)
```

## Clean Data

```{r}
#| label: reduce-data

smaller_df <- combined_df |> 
  filter(str_starts(student_acad_prog, "A&S")) |> # Remove Pratt
  filter(str_sub(student_group, 1, 2) != "TR") |> # Remove Transfers
  mutate(
    student_group = str_replace(student_group, "^..", "20"),
    student_group = as.numeric(student_group),
    term_enrolled = as.numeric(term_enrolled),
  ) |>
  filter(student_group > 2011) |> # Remove prior to P/F -> S/U F2012
  mutate( # Compute number of academic plans
    num_plans = rowSums(
      !is.na(pick(first_major, second_major,
                  first_minor, second_minor,
                  first_certificate, second_certificate))
    )
  ) |> # Drop extra variables
  dplyr::select(-c(
    first_minor, first_minor_desc, second_minor, second_minor_desc, 
    first_certificate, first_certificate_desc, 
    second_certificate, second_certificate_desc, 
    career, student_acad_prog, course_crosslisted, class_nbr_rev
  )) 
```

```{r}
#| label: term-codes

term_lookup <- tribble(
  ~term_number, ~term_enrolled_new,  ~year_enrolled,
  1400,         "Summer Full 2012", "2011-2012",
  1405,         "Summer 1 2012",    "2011-2012",
  1410,         "Summer 2 2012",    "2012-2013",
  1420,         "Fall 2012",        "2012-2013",
  1430,         "Spring 2013",      "2012-2013",
  1440,         "Summer Full 2013", "2012-2013",
  1445,         "Summer 1 2013",    "2012-2013",
  1450,         "Summer 2 2013",    "2013-2014",
  1460,         "Fall 2013",        "2013-2014",
  1470,         "Spring 2014",      "2013-2014",
  1480,         "Summer Full 2014", "2013-2014",
  1485,         "Summer 1 2014",    "2013-2014",
  1490,         "Summer 2 2014",    "2014-2015",
  1500,         "Fall 2014",        "2014-2015",
  1510,         "Spring 2015",      "2014-2015",
  1520,         "Summer Full 2015", "2014-2015",
  1525,         "Summer 1 2015",    "2014-2015",
  1530,         "Summer 2 2015",    "2015-2016",
  1540,         "Fall 2015",        "2015-2016",
  1550,         "Spring 2016",      "2015-2016",
  1565,         "Summer 1 2016",    "2015-2016",
  1570,         "Summer 2 2016",    "2016-2017",
  1580,         "Fall 2016",        "2016-2017",
  1590,         "Spring 2017",      "2016-2017",
  1605,         "Summer 1 2017",    "2016-2017",
  1610,         "Summer 2 2017",    "2017-2018",
  1620,         "Fall 2017",        "2017-2018",
  1630,         "Spring 2018",      "2017-2018",
  1645,         "Summer 1 2018",    "2017-2018",
  1650,         "Summer 2 2018",    "2018-2019",
  1660,         "Fall 2018",        "2018-2019",
  1670,         "Spring 2019",      "2018-2019",
  1685,         "Summer 1 2019",    "2018-2019",
  1690,         "Summer 2 2019",    "2019-2020",
  1700,         "Fall 2019",        "2019-2020",
  1710,         "Spring 2020",      "2019-2020",
  1725,         "Summer 1 2020",    "2019-2020",
  1730,         "Summer 2 2020",    "2020-2021",
  1740,         "Fall 2020",        "2020-2021",
  1750,         "Spring 2021",      "2020-2021",
  1765,         "Summer 1 2021",    "2020-2021",
  1770,         "Summer 2 2021",    "2021-2022",
  1780,         "Fall 2021",        "2021-2022",
  1790,         "Spring 2022",      "2021-2022",
  1805,         "Summer 1 2022",    "2021-2022",
  1810,         "Summer 2 2022",    "2022-2023",
  1820,         "Fall 2022",        "2022-2023",
  1830,         "Spring 2023",      "2022-2023",
  1845,         "Summer 1 2023",    "2022-2023",
  1850,         "Summer 2 2023",    "2023-2024",
  1860,         "Fall 2023",        "2023-2024",
  1870,         "Spring 2024",      "2023-2024",
  1885,         "Summer 1 2024",    "2023-2024",
  1890,         "Summer 2 2024",    "2024-2025",
  1900,         "Fall 2024",        "2024-2025",
  1910,         "Spring 2025",      "2024-2025"
)

term_levels <- c(
  "Summer Full 2012",
  "Summer 1 2012",
  "Summer 2 2012",
  "Fall 2012",
  "Spring 2013",
  "Summer Full 2013",
  "Summer 1 2013",
  "Summer 2 2013",
  "Fall 2013",
  "Spring 2014",
  "Summer Full 2014",
  "Summer 1 2014",
  "Summer 2 2014",
  "Fall 2014",
  "Spring 2015",
  "Summer Full 2015",
  "Summer 1 2015",
  "Summer 2 2015",
  "Fall 2015",
  "Spring 2016",
  "Summer 1 2016",
  "Summer 2 2016",
  "Fall 2016",
  "Spring 2017",
  "Summer 1 2017",
  "Summer 2 2017",
  "Fall 2017",
  "Spring 2018",
  "Summer 1 2018",
  "Summer 2 2018",
  "Fall 2018",
  "Spring 2019",
  "Summer 1 2019",
  "Summer 2 2019",
  "Fall 2019",
  "Spring 2020",
  "Summer 1 2020",
  "Summer 2 2020",
  "Fall 2020",
  "Spring 2021",
  "Summer 1 2021",
  "Summer 2 2021",
  "Fall 2021",
  "Spring 2022",
  "Summer 1 2022",
  "Summer 2 2022",
  "Fall 2022",
  "Spring 2023",
  "Summer 1 2023",
  "Summer 2 2023",
  "Fall 2023",
  "Spring 2024",
  "Summer 1 2024",
  "Summer 2 2024",
  "Fall 2024",
  "Spring 2025"
)

term_df <- smaller_df |>
  left_join(
    term_lookup,
    by = c("term_enrolled" = "term_number")
  ) |>
  mutate(
    term_enrolled = factor(term_enrolled_new,
                           levels = term_levels, ordered = TRUE),
  ) |>
  dplyr::select(-c(term_enrolled_new))
```

```{r}
#| label: types-SU-timeperiod
clean_df <- term_df |>
  rename(num_students = Tot_Enrl) |>
  mutate(
    catalog_level = factor(
      catalog_level,
      levels = c("1-99", "100-199", "200-299", 
                 "300-399", "400-499", "500 and above"),
      ordered = TRUE
    ),
    year_enrolled = factor(
      year_enrolled, levels = sort(unique(year_enrolled)), ordered = TRUE
    ),
    masked_student_ID = as.character(masked_student_ID),
    academic_level_bot = recode(academic_level_bot,
                                "1st Year Undergraduate" = "1st Year",
                                "5th Year Undergraduate" = "5th Year"
                                ),
    academic_level_bot = factor(
      academic_level_bot,
      levels = c("1st Year", "Sophomore", "Junior", "Senior", "5th Year"),
      ordered = TRUE
    ),
    is_SU = if_else(final_grade %in% c("S", "U", "P"), 1, 0),
    timeperiod = case_when(
      term_enrolled < "Spring 2020" ~ "pre_covid",
      term_enrolled > "Summer 2 2022" ~ "post_covid",
      TRUE ~ "dur_covid"
    ),
    timeperiod = factor(timeperiod, 
                        levels = c("pre_covid", "dur_covid", "post_covid"), 
                        ordered = TRUE)
  ) |>
  group_by(masked_student_ID) |>
  mutate(did_indep_study = any(class_component == "IND")) |>
  ungroup()
```

```{r}
#| label: 8-sem-grads

just_8sem_ids <- clean_df |>
  filter(!str_starts(term_enrolled, "Summer")) |>
  distinct(masked_student_ID, term_enrolled) |>  # each term counts once
  group_by(masked_student_ID) |>
  summarise(max_semester = n(), .groups = "drop") |>
  filter(max_semester == 8) |>
  pull(masked_student_ID)

only8_sem_df <- clean_df |> 
  filter(masked_student_ID %in% just_8sem_ids | student_group >= 2022)
```

```{r}
#| label: course-load

# mark underload semesters (cannot S/U if underloading)
actual_load_df <- only8_sem_df |>
  group_by(masked_student_ID, term_enrolled) |>
  mutate(actual_units = sum(max_units, na.rm = TRUE)) |>
  ungroup() |>
  mutate(actual_load = case_when(
    actual_units < 4.0 ~ "underload",
    actual_units == 4.0 ~ "normal",
    actual_units > 4.0 ~ "overload"
  ))

# remove "non-academic" courses
# all ACT courses are either NA or < 1 credit
# majority of MUS and STU are < 1, assuming NA are < 1
academ_df <- actual_load_df |>
  filter(division != "Other") |>
  filter(class_component != "ACT") |> 
  filter(!(class_component == "MUS" & (max_units < 1 | is.na(max_units)))) |> 
  filter(!(class_component == "STU" & (max_units < 1 | is.na(max_units))))

course_load_df <- academ_df |>
  arrange(masked_student_ID, term_enrolled) |>
  group_by(masked_student_ID, term_enrolled) |>
  summarise(
    term_units = sum(max_units, na.rm = TRUE),
    .groups = "drop"
  ) |>
  group_by(masked_student_ID) |>
  arrange(term_enrolled) |>
  mutate(
    # Increment semester counter, represents which semester not how many
    semester_num = cumsum(!grepl("^Summer", term_enrolled)),
    # Increment overload if term_units > 4
    num_overloads = cumsum(term_units > 4 & !grepl("^Summer", term_enrolled)),
    load_status = case_when(
      term_units < 4    ~ "underload",
      term_units == 4   ~ "normal",
      term_units > 4    ~ "overload",
    )
  ) |>
  ungroup()

numbered_df <- academ_df |>
  left_join(
    course_load_df, by = c("masked_student_ID", "term_enrolled")
  )

# Compare actual vs acad units
comparison_df <- numbered_df |>
  group_by(masked_student_ID, term_enrolled) |>
  summarise(
    actual_units = unique(actual_units),
    term_units   = unique(term_units),
    .groups = "drop"
  ) |>
  mutate(
    diff = actual_units - term_units,
    same_units = (diff == 0),
    underload_flag = actual_units < 4.0
  )
comparison_df |>
  summarise(
    n_total = n(),
    n_diff = sum(!same_units),
    pct_diff = 100 * n_diff / n_total,
    mean_diff = mean(diff, na.rm = TRUE),
    median_diff = median(diff, na.rm = TRUE)
  )
comparison_df |>
  filter(!same_units) |>
  group_by(term_enrolled) |>
  summarise(
    n = n(),
    mean_diff = mean(diff, na.rm = TRUE),
    .groups = "drop"
  ) |>
  arrange(desc(n))

# Compare actual vs acad load categories
load_comparison_df <- numbered_df |>
  group_by(masked_student_ID, term_enrolled) |>
  summarise(
    actual_load = unique(actual_load),
    load_status = unique(load_status),
    .groups = "drop"
  ) |>
  mutate(
    same_load = (actual_load == load_status)
  )
load_comparison_df |>
  summarise(
    n_total = n(),
    n_diff = sum(!same_load, na.rm = TRUE),
    pct_diff = 100 * n_diff / n_total
  )
load_comparison_df |>
  filter(!same_load) |>
  count(actual_load, load_status) |>
  arrange(desc(n))
load_comparison_df |>
  group_by(term_enrolled) |>
  summarise(
    n = n(),
    n_diff = sum(!same_load, na.rm = TRUE),
    pct_diff = 100 * n_diff / n,
    .groups = "drop"
  ) |>
  arrange(desc(pct_diff))

# academic_level_bot doesn't align with semester_num
misalign <- numbered_df |>
  filter(!is.na(semester_num), !is.na(academic_level_bot)) |>
  count(semester_num, academic_level_bot) |>
  pivot_wider(names_from = academic_level_bot, 
              values_from = n, values_fill = 0)
misalign

saveRDS(misalign, "figures/misalign.rds")

```

```{r}
#| label: study-away

away_df <- numbered_df |>
  mutate(
    location = case_when(
      location %in% c("DURHAM", "ONLINE") ~ location,
      is.na(location) ~ NA, 
      TRUE ~ "AWAY"
    )
  )

studied_away <- away_df |>
  group_by(masked_student_ID) |>
  summarise(
    studied_away = case_when(
      any(location == "AWAY", na.rm = TRUE) ~ 1L,
      any(is.na(location)) ~ NA,
      TRUE ~ 0L
    ),
    .groups = "drop"
  )
away_df <- away_df |>
  left_join(studied_away, by = "masked_student_ID")
```

```{r}
#| label: summer

summer_student <- away_df |>
  group_by(masked_student_ID) |>
  summarise(
    took_summer_courses = as.integer(any(str_starts(term_enrolled, "Summer"))),
    .groups = "drop"
  )
summer_df <- away_df |>
  left_join(summer_student, by = "masked_student_ID")

no_summer_df <- summer_df |>
  filter(!str_starts(term_enrolled, "Summer"))
```

```{r}
#| label: major-divisons

major_mapping <- read_excel("major_divisions.xlsx")

student_divisions <- no_summer_df |>
  dplyr::select(masked_student_ID, first_major_descr, second_major_descr) |>
  pivot_longer(cols = c(first_major_descr, second_major_descr), 
               names_to = "major_type", values_to = "major") |>
  filter(!is.na(major)) |>
  mutate(
    major_clean = str_remove(major, "\\s*\\([^)]*\\)$")
  ) |>
  left_join(major_mapping, by = "major_clean") |>
  group_by(masked_student_ID) |>
  summarise(
    is_art_humanity = as.integer(any(is_art_humanity == 1, na.rm = TRUE)),
    is_social_sci   = as.integer(any(is_social_sci == 1, na.rm = TRUE)),
    is_natural_sci  = as.integer(any(is_natural_sci == 1, na.rm = TRUE)),
    tbd             = as.integer(any(tbd == 1, na.rm = TRUE)),
    .groups = "drop"
  ) 

divisions_df <- no_summer_df |>
  left_join(student_divisions, by = "masked_student_ID") |> 
  filter(!(tbd == 1L) | is.na(tbd)) # Drop Program 2 and unknown IDM
```

```{r}
#| label: GPA

grade_points <- c(
  "A+" = 4.0, "A" = 4.0, "A-" = 3.7,
  "B+" = 3.3, "B" = 3.0, "B-" = 2.7,
  "C+" = 2.3, "C" = 2.0, "C-" = 1.7,
  "D+" = 1.3, "D" = 1.0, "D-" = 1.0,
  "F" = 0.0
)

# One row per student per semester
semGPA_df <- divisions_df |>
  mutate(
    grade_points = grade_points[final_grade]
  ) |>
  filter(
    final_grade %in% names(grade_points)
  ) |>
  group_by(masked_student_ID, term_enrolled) |>
  summarize(
    semGPA = sum(grade_points * max_units, na.rm = TRUE) 
              / sum(max_units, na.rm = TRUE),
    .groups = "drop"
  )

prevGPA_df <- semGPA_df |>
  arrange(masked_student_ID, term_enrolled) |>
  group_by(masked_student_ID) |>
  mutate(prev_semGPA = lag(semGPA)) |>
  ungroup()

gpa_df <- divisions_df |>
  left_join(
    prevGPA_df |> 
      dplyr::select(masked_student_ID, term_enrolled, prev_semGPA),
    by = c("masked_student_ID", "term_enrolled")
  )

eda_df <- gpa_df |>
  filter(division != "Engineering") |>
  filter(division != "WRITING") |>
  filter(!is.na(course_ID)) |>
  filter(str_detect(location, "DURHAM") | str_detect(location, "ONLINE")) |>
  filter(!is.na(catalog_level))

saveRDS(eda_df, file = "data/eda_df.rds")
```

```{r}
#| label: eda-gpa

gpa_summary <- prevGPA_df |>
  group_by(term_enrolled) |>
  summarise(
    q25 = quantile(semGPA, 0.25, na.rm = TRUE),
    q50 = quantile(semGPA, 0.50, na.rm = TRUE),
    q75 = quantile(semGPA, 0.75, na.rm = TRUE),
    .groups = "drop"
  )

deans_list <- read_xlsx("deans_list.xlsx")
deans_list <- deans_list |>
  rename(term_enrolled = Term)

gpa_plot <- ggplot() +
  geom_ribbon(
    data = gpa_summary,
    aes(x = term_enrolled, ymin = q25, ymax = q75, group = 1),
    fill = "lightgray"
  ) +
  geom_line(
    data = gpa_summary,
    aes(x = term_enrolled, y = q50, group = 1),
  ) +
  geom_line(
    data = deans_list,
    aes(x = term_enrolled, y = `Dean's List`, group = 1),
    color = "red",
    linetype = "dashed",
  ) +
  labs(
    title = "Semester GPA Quantiles and Dean’s List Rate Over Time",
    x = "Term",
    y = "Weighted GPA",
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  annotate("text", y = 3.4, x = "Spring 2021", 
           label = "Red = Dean's List Cutoff \nBlack = Previous Semester GPA",
           size = 3)
gpa_plot

ggsave("figures/gpa_plot.png", plot = gpa_plot, dpi = 300)
```

```{r}
#| label: remove-su-required
all_grades <- c("A+", "A", "A-", "B+", "B", "B-", 
                "C+", "C", "C-", "D+", "D", "D-", "F")

# Courses with no A-F grades
courses_no_grades <- gpa_df |>
  group_by(term_enrolled, course_ID) |>
  summarize(letter_grades = any(final_grade %in% all_grades), 
            .groups = "drop") |>
  filter(!letter_grades) |>
  dplyr::select(term_enrolled, course_ID)

nrow(courses_no_grades)

graded_df <- gpa_df |>
  anti_join(courses_no_grades, by = c("term_enrolled", "course_ID"))
```

```{r}
#| label: filter-courses

valid_courses_df <- graded_df |>
  filter(division != "Engineering") |>
  filter(division != "WRITING") |>
  filter(!is.na(course_ID)) |>
  filter(str_detect(location, "DURHAM") | str_detect(location, "ONLINE")) |>
  filter(!is.na(catalog_level)) |>
  # Remove non-credited courses (withdraws, audits, etc)
  filter(final_grade %in% c("A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", 
                            "D+", "D", "D-", "F", "S", "U"))
```

```{r}
#| label: missing-data-after

glimpse(valid_courses_df)

missing_summary <- valid_courses_df |>
  summarise(across(
    everything(),
    list(
      n_missing = ~sum(is.na(.)),
      prop_missing = ~mean(is.na(.))
    ),
    .names = "{.col}-{.fn}"
  )) |>
  pivot_longer(
    everything(),
    names_to = c("variable", ".value"),
    names_sep = "-"
  ) |>
  arrange(desc(n_missing))
          
print(missing_summary, n = Inf)
```

## Impute Major Divisions

```{r}
#| label: best-threshold
students_with_major <- valid_courses_df |>
  filter(!is.na(first_major) & student_group > 2019 & student_group < 2023) |>
  filter(max_units >= 1)

division_cols <- c("Arts & Humanities", "Social Sciences", "Natural Sciences")
p_vals <- seq(0.1, 0.9, by = 0.05)  # candidate proportion thresholds

# Upper-level (>199) course proportions
student_div_props <- students_with_major |>
  filter(!is.na(division),
         !(division %in% c("WRITING", "Engineering")),
         catalog_level > "100-199") |>
  group_by(masked_student_ID, division) |>
  summarise(n_div_courses = n(), .groups = "drop_last") |>
  mutate(total_200 = sum(n_div_courses)) |>
  ungroup() |>
  filter(total_200 >= 3) |>  # at least 3 upper-level courses
  mutate(prop_division = n_div_courses / total_200)

# True major divisions
student_flags <- students_with_major |>
  dplyr::select(masked_student_ID, is_art_humanity:is_natural_sci) |>
  pivot_longer(
    cols = is_art_humanity:is_natural_sci,
    names_to = "division_flag",
    values_to = "is_division"
  ) |>
  mutate(
    division = case_when(
      division_flag == "is_art_humanity" ~ "Arts & Humanities",
      division_flag == "is_social_sci"  ~ "Social Sciences",
      division_flag == "is_natural_sci" ~ "Natural Sciences",
      TRUE ~ division_flag
    )
  ) |>
  filter(division %in% division_cols) |>
  dplyr::select(masked_student_ID, division, is_division) |>
  distinct()

check_table <- student_div_props |>
  left_join(student_flags, by = c("masked_student_ID", "division"))

# Computes classification error at a given proportion threshold
compute_error <- function(p_thresh) {
  check_table |>
    mutate(
      took_gt_p = prop_division > p_thresh
    ) |>
    group_by(division) |>
    summarise(
      TP = sum(took_gt_p & is_division == 1, na.rm = TRUE),
      FP = sum(took_gt_p & is_division == 0, na.rm = TRUE),
      TN = sum(!took_gt_p & is_division == 0, na.rm = TRUE),
      FN = sum(!took_gt_p & is_division == 1, na.rm = TRUE),
      .groups = "drop"
    ) |>
    mutate(
      p = p_thresh,
      error_rate = (FP + FN) / (TP + FP + TN + FN)
    )
}

errors_by_p <- map_dfr(p_vals, compute_error)

impute_error_plot <- ggplot(errors_by_p, 
                            aes(x = p, y = error_rate, color = division)) +
  geom_line() +
  geom_point() +
  labs(
    x = "Proportion Threshold (p)",
    y = "Error Rate",
    title = "Error Rate vs Proportion Threshold"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
impute_error_plot
ggsave("figures/impute_error_plot.png", impute_error_plot)

best_p <- errors_by_p |>
  group_by(division) |>
  slice_min(error_rate, n = 1) |>
  dplyr::select(division, best_p = p, error_rate)

# Use best threshold to classify students
student_flags_estimated <- check_table |>
  left_join(best_p, by = "division") |>
  mutate(
    estimated_flag = prop_division > best_p
  )

best_p <- student_flags_estimated |>
  group_by(division) |>
  summarise(
    accuracy = mean(estimated_flag == (is_division == 1), na.rm = TRUE),
    best_p = unique(best_p)
  )
best_p

saveRDS(best_p, "figures/best_p.rds")
```

```{r}
#| label: error-plot
# for each candidate proportion threshold
confusion_table <- map_dfr(p_vals, function(p_thresh) {
  check_table |>
    mutate(predicted = prop_division > p_thresh) |>
    group_by(division) |>
    summarise(
      TP = sum(predicted & is_division == 1, na.rm = TRUE),
      FP = sum(predicted & is_division == 0, na.rm = TRUE),
      FN = sum(!predicted & is_division == 1, na.rm = TRUE),
      TN = sum(!predicted & is_division == 0, na.rm = TRUE),
      .groups = "drop"
    ) |>
    mutate(threshold = p_thresh)
})

confusion_long <- confusion_table |>
  pivot_longer(cols = TP:TN, names_to = "metric", values_to = "count")

confusion_metrics <- ggplot(confusion_long, 
                            aes(x = threshold, y = count, color = metric)) +
  geom_line() +
  facet_wrap(~division, scales = "free_y") +
  labs(
    title = "TP/FP/FN/TN counts vs proportion threshold",
    x = "Proportion threshold",
    y = "Number of students",
    color = "Confusion Metric"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
confusion_metrics
ggsave("figures/impute_confusion_plot.png", confusion_metrics)
```

```{r}
#| label: make-predictions
# Imputing for students with at least 8 semesters and ignoring those 
# who may have dropped out prior to 2019
students_no_major <- valid_courses_df |>
  filter(is.na(first_major) & student_group %in% c(2022, 2023)) |>
  filter(max_units >= 1)

# Compute upper-level course proportions
student_div_props_no_major <- students_no_major |>
  filter(!is.na(division),
         !(division %in% c("WRITING", "Engineering")),
         catalog_level > "100-199") |>
  group_by(masked_student_ID, division) |>
  summarise(n_div_courses = n(), .groups = "drop_last") |>
  mutate(total_200 = sum(n_div_courses)) |>
  ungroup() |>
  filter(total_200 >= 3) |> # require at least 3 upper-level courses
  mutate(prop_division = n_div_courses / total_200)

student_div_props_no_major <- student_div_props_no_major |>
  left_join(best_p, by = "division")

# Impute
student_div_props_no_major <- student_div_props_no_major |>
  mutate(estimated_flag = prop_division > best_p)

predicted_divisions <- student_div_props_no_major |>
  filter(estimated_flag) |>
  group_by(masked_student_ID) |>
  summarise(predicted_divisions = paste(division, collapse = ", "), 
            .groups = "drop")

predicted_majors <- predicted_divisions |>
  count(predicted_divisions, sort = TRUE)
predicted_majors

saveRDS(predicted_majors, "figures/predicted_majors.rds")
```

```{r}
#| label: join-predictions

predicted_flags_wide <- predicted_divisions |>
  # one row per student per predicted division
  separate_rows(predicted_divisions, sep = ",\\s*") |>
  mutate(value = 1) |>
  pivot_wider(
    names_from = predicted_divisions,
    values_from = value,
    values_fill = 0
  ) |>
  rename(
    is_art_humanity = `Arts & Humanities`,
    is_social_sci   = `Social Sciences`,
    is_natural_sci  = `Natural Sciences`
  ) |>
  mutate(num_plans = is_art_humanity + is_social_sci + is_natural_sci,
         estimated = TRUE)

final_with_estimates <- valid_courses_df |>
  left_join(predicted_flags_wide, by = "masked_student_ID") |>
  # replace only for students with predictions
  mutate(
    is_art_humanity = coalesce(is_art_humanity.y, is_art_humanity.x),
    is_social_sci   = coalesce(is_social_sci.y,   is_social_sci.x),
    is_natural_sci  = coalesce(is_natural_sci.y,  is_natural_sci.x),
    num_plans       = coalesce(num_plans.y, num_plans.x),
    estimated       = coalesce(estimated, FALSE)
  ) |>
  dplyr::select(-ends_with(".x"), -ends_with(".y"))
```

```{r}
#| label: comparison
# Compare estimates with actual
final_with_estimates |>
  filter(estimated == TRUE) |>
  mutate(n_divisions = is_art_humanity + is_social_sci + is_natural_sci) |>
  count(n_divisions)

final_with_estimates |>
  filter(estimated == FALSE) |>
  mutate(n_divisions = is_art_humanity + is_social_sci + is_natural_sci) |>
  count(n_divisions)

final_with_estimates |>
  count(num_plans)
```

## Across Year Test

```{r}
#| label: across-years
students_with_major <- valid_courses_df |>
  filter(!is.na(first_major)) |>
  filter(max_units >= 1)

division_cols <- c("Arts & Humanities", "Social Sciences", "Natural Sciences")
p_vals <- seq(0.1, 0.9, by = 0.05)  # candidate proportion thresholds

# Count courses per student × division × student_group
student_div_counts <- students_with_major |>
  filter(!is.na(division),
         !(division %in% c("WRITING", "Engineering")),
         catalog_level > "100-199") |>
  group_by(masked_student_ID, student_group, division) |>
  summarise(n_div_courses = n(), .groups = "drop")

# Compute total upper-level courses per student (across divisions)
student_div_props <- student_div_counts |>
  group_by(masked_student_ID, student_group) |>
  mutate(total_200 = sum(n_div_courses)) |>
  ungroup() |>
  filter(total_200 >= 3) |>
  mutate(prop_division = n_div_courses / total_200)

# Get "true" divisions
student_flags <- students_with_major |>
  dplyr::select(masked_student_ID, student_group, 
                is_art_humanity:is_natural_sci) |>
  pivot_longer(
    cols = is_art_humanity:is_natural_sci,
    names_to = "division_flag",
    values_to = "is_division"
  ) |>
  mutate(
    division = case_when(
      division_flag == "is_art_humanity" ~ "Arts & Humanities",
      division_flag == "is_social_sci"  ~ "Social Sciences",
      division_flag == "is_natural_sci" ~ "Natural Sciences",
      TRUE ~ division_flag
    )
  ) |>
  filter(division %in% division_cols) |>
  dplyr::select(masked_student_ID, student_group, division, is_division) |>
  distinct()

check_table <- student_div_props |>
  left_join(student_flags, 
            by = c("masked_student_ID", "student_group", "division"))

# Compute classification error at a given threshold
compute_error <- function(p_thresh) {
  check_table |>
    mutate(took_gt_p = prop_division > p_thresh) |>
    group_by(student_group, division) |>
    summarise(
      TP = sum(took_gt_p & is_division == 1, na.rm = TRUE),
      FP = sum(took_gt_p & is_division == 0, na.rm = TRUE),
      TN = sum(!took_gt_p & is_division == 0, na.rm = TRUE),
      FN = sum(!took_gt_p & is_division == 1, na.rm = TRUE),
      .groups = "drop"
    ) |>
    mutate(
      p = p_thresh,
      error_rate = (FP + FN) / pmax(TP + FP + TN + FN, 1)  # safe divide
    )
}

errors_by_p <- map_dfr(p_vals, compute_error)

best_p <- errors_by_p |>
  group_by(student_group, division) |>
  filter(error_rate == min(error_rate, na.rm = TRUE)) |>
  arrange(p) |>
  slice(1) |>
  ungroup() |>
  dplyr::select(student_group, division, best_p = p, min_error = error_rate)

# Apply best thresholds 
student_flags_estimated <- check_table |>
  left_join(best_p, by = c("student_group", "division")) |>
  mutate(estimated_flag = prop_division > best_p)

# Accuracy by student group and division
accuracy_by_group <- student_flags_estimated |>
  group_by(student_group, division) |>
  reframe(
    accuracy = mean(estimated_flag == (is_division == 1), na.rm = TRUE),
    best_p = unique(best_p),
    min_error = unique(min_error)
  ) |>
  arrange(division, student_group)

accuracy_by_year <- ggplot(accuracy_by_group, 
                    aes(x = student_group, y = best_p, color = division)) +
  geom_point(size = 3) +
  geom_line(aes(group = division), linewidth = 1) +
  labs(
    title = "Best Thresholds",
    x = "Student Group",
    y = "Best Threshold",
    color = "Division"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.minor = element_blank()
  )

error_by_years_plot <- ggplot(accuracy_by_group, 
                    aes(x = student_group, y = min_error, color = division)) +
  geom_point(size = 3) +
  geom_line(aes(group = division), linewidth = 1) +
  labs(
    title = "Minimum Error",
    x = "Student Group",
    y = "Minimum Error",
    color = "Division"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.minor = element_blank()
  )

impute_by_year_plot <- (accuracy_by_year + error_by_years_plot) +
  plot_layout(guides = "collect") &
  theme(legend.position = "bottom")
impute_by_year_plot
ggsave("figures/impute_by_year.png", plot = impute_by_year_plot, dpi = 300)
```

## Final Data Cleaning

```{r}
#| label: cleaning
model_df <- final_with_estimates |>
  dplyr::select(-c(first_major, first_major_descr, 
            second_major, second_major_descr, 
            tbd, location, class_component)) |>
  filter(actual_load != "underload") |>
  mutate(
    studied_away = if_else(is.na(studied_away), FALSE, studied_away),
    prev_semGPA  = if_else(is.na(prev_semGPA), 4, prev_semGPA),
    final_grade = recode(final_grade,
      "A+" = "A_plus",
      "A"  = "A",
      "A-" = "A_minus",
      "B+" = "B_plus",
      "B"  = "B",
      "B-" = "B_minus",
      "C+" = "C_plus",
      "C"  = "C",
      "C-" = "C_minus",
      "D+" = "D_plus",
      "D"  = "D",
      "D-" = "D_minus",
      "F"  = "F"
  ))
```

```{r}
#| label: missingness

# number of plans is discrete, 0 plans is impossible -> claim 1
model_df$num_plans <- factor(
  ifelse(model_df$num_plans == 0, 1, model_df$num_plans),
  levels = c(1, 2, 3),
  ordered = TRUE
)
```

```{r}
#| label: class-imbalance

# Imbalance of S/U vs A-F
model_df |>
  count(is_SU) |>
  mutate(prop = n / sum(n))

# Imbalance by student group
model_df |>
  group_by(student_group) |>
  summarise(
    n_total   = n(),
    n_true    = sum(is_SU == "1", na.rm = TRUE),
    n_false   = sum(is_SU == "0", na.rm = TRUE),
    prop_true = mean(is_SU == "1", na.rm = TRUE)
  ) |>
  arrange(desc(prop_true))

# Chose to drop data prior to Fall 2015
model_df <- model_df |>
  mutate(is_SU = factor(is_SU, levels = c(0, 1))) |>
  filter(term_enrolled > "Summer 2 2015")

# Slightly improved imbalance of S/U A-F
model_df |>
  count(is_SU) |>
  mutate(prop = n / sum(n))

# Most courses are 1.0 credits
model_df |>
  count(max_units) |>
  mutate(prop = n / sum(n))

# A lot of uncommon term_units
model_df |>
  count(term_units) |>
  mutate(prop = n / sum(n)) |>
  print(n = Inf)

# Relatively balanced when using categories instead of units
model_df |>
  count(load_status) |>
  mutate(prop = n / sum(n))

# Can only S/U 1.0 credit courses(?)
model_df <- model_df |>
  filter(max_units == 1.0) |>
  mutate(
    load_status = case_when(
      term_units < 4    ~ "underload",
      term_units == 4   ~ "normal",
      term_units > 4    ~ "overload",
      TRUE              ~ NA_character_   # handles any missing cases
    ),
    actual_load = factor(
      actual_load,
      levels = c("normal", "overload"),
      ordered = TRUE
    ),
    load_status = factor(
      load_status,
      levels = c("underload", "normal", "overload"),
      ordered = TRUE
    ),
  )

# Final class imbalance
model_df |>
  count(is_SU) |>
  mutate(prop = n / sum(n))

saveRDS(model_df, file = "data/model_df.rds")
```

```{r}
#| label: missing-data-final

glimpse(model_df)

missing_final <- model_df |>
  summarise(across(
    everything(),
    list(
      n_missing = ~sum(is.na(.)),
      prop_missing = ~mean(is.na(.))
    ),
    .names = "{.col}-{.fn}"
  )) |>
  pivot_longer(
    everything(),
    names_to = c("variable", ".value"),
    names_sep = "-"
  ) |>
  arrange(desc(n_missing))
          
print(missing_final, n = Inf)
```
